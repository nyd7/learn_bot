'''
Расстановка имопрта в коде такая, как нужно загружаться по приоритету.
- Библиотека logging - отлавливает и классифицирует ошибки (изучай отедльно библиотеку),
поэтому она первая.
- Библитотека telegram.ext  - содержит основный инструменты для работы Телеграм, но ошибки важнее,
потому она вторая.
- settings - это нами же созданный файл (модуль), который содержит коды доступа, 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

Шаг 1 - Из библиотеки telegram.ext импортируем Класс Updater, из которых позже возьмем 
функции start_polling и idle

Импортировали свой файл.ру settings.py

Шаг 2 - Из библиотеки telegram.ext импортируем Классы словарей CommandHandler, MessageHandler и
Filters для более точной фильтрации получаемых сообщений

Шаг 3 - Импортируем бибилотеку logging, с помощье нее сможем получать и обрабатывать сообщения 
о процессах и ошибках
'''
import logging
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
import settings

'''
Шаг 3.1 -"Не молчи"
(Предварительно импоритровали logging)
По умолчанию telegram.ext не выводит сообщений о процесах и ошибках на экран,
а нам надо знать, что происходит.
Есть 4 типа ошибок. Дебаг - прям все по шагам показывает, Инфо и 
еще 2 вида-уровня (вроде, см. документацию к logging).
Нам устраивает уровень INFO.
Поэтому создаем (автоматически) файл bot.log, куда все будет записываться, и
устанавливаем уровень сложности процессов которые хотим записывать level=logging.INFO
'''

logging.basicConfig(filename='bot.log', level=logging.INFO)
'''
Шаг 1.4 - "Обходим"
Параметры учебного PROXY-сервера.
Вначале задали прямые параметры (имена, пароли), но чтобы их не раскрывать - мы сохранили их
в отельный файл settings.py, а сюда только указали переменные в которых они хранятся.
Чтобы файл не попал на Гит - мы занесли название файла в /.gitignor
'''

PROXY = {
    'proxy_url': settings.PROXY_URL,
    'urllib3_proxy_kwargs': {
        'username': settings.PROXY_USERNAME, 
        'password': settings.PROXY_PASSWORD
    }
}

'''
Шаг 4 - "Отвечаем на /start'"

update - содержит полученную информацию от пользователя и о самом пользователе
context - специальный тумблер (переключатель), который нам позволяет сразу из этой фунции
отправлять комнды папе-боту, через которого мы уже сможем отправлять сообщения не только тому
пользователю, что нас вызвал, но и другому, к примеру.

print('Вызван /start') - сообщили себе в консоли, что произошло такое событие

update.message.reply_text('Привет, пользователь! Ты зачем нажал /start?') - отвчаем пользователю
update - база данных (содеражия в т.ч. обратный адрес и т.д.)
.message - тип данных - сообщение
.reply_text - отправить текст
() - в скобках содержание текстового ответа, которое получит пользователь
'''

def greet_user(update, context):
    print('Вызван /start')
    #print(update) - посмотрели содержимое update
    #print(1/0) - поверяли то, что без logging ошибки не увидим
    update.message.reply_text('Привет, пользователь! Ты зачем нажал /start?')

'''
Шаг 5 - Отвечаем на входящий текст входяшим текстом
update.message.text - текст полученный от пользователя
update - база данных (содеражищая в т.ч. обратный адрес и т.д.)
.message - тип данных - сообщение
.text - текст полученный от пользователя

update.message.reply_text(user_text) отвечае пользователю его же текстом.
На вход и выход у нас было update.message., отличие только в том, что
.text - полученный текст
.reply_text() - отвечаемый текст

'''

def talk_to_me(update, context):
    user_text = update.message.text 
    print(user_text)
    update.message.reply_text(user_text)

def main():
    '''
    Шаг 1.1 - "Предъявите документы"
    (Предварительно импоритровали Updater)

    Создаем бота и передаем ему ключ для авторизации на серверах Telegram: 
    mybot - создаем переменную, где будут основные параметры на вхождение в систему Телеграма.
    Дальше, мы будем еще применять методы к свойствам Updater, но чтобы, не писать каждый раз
    Updater с параметрами на вход - мы все заключили в одной переменной mybot

    Updater("КЛЮЧ, КОТОРЫЙ НАМ ВЫДАЛ BotFather") - ключ полученный при регистрации бота

    use_context=True - значение по умолчанию, нужно для старых версий, оставляем как есть.

    request_kwargs - опередедяет способ подключения к серверу. Можно не включать параметр.
    Но т.к. мы хотим избежать блокировки бота, из-за блокриовки Телеграма, то задем ему
    параметры, как подключиться через удаленный сервер. 
    Данный удаленный сервер (см. содержание переменной PROXY) - учебный.
    =PROXY - задаем адрес подключения. см. содрежание переменной в коде выше.
    Библиотека: https://python-telegram-bot.readthedocs.io/en/stable/telegram.ext.updater.html 
    '''
    mybot = Updater(settings.API_KEY, use_context=True, request_kwargs=PROXY)
    
    '''
    Шаг 2.1 - "Чё сказал? - То получил"
    
    dp = mybot.dispatcher - Переходим в класс Dispatcher, и создаем для удобства переменную dp
    Диспетчер прогоняет (ищет как ключ) полученный запрос по всем 
    Словарям-Handler-ам (CommandHandler, MessageHandler, и прочие)
    и получив обратную связь от первого попавшегося, 
    что такой есть - запускает значение по ключу (обработчика)

    (Предварительно импортировали CommandHandler)
    CommandHandler - словарь принимаемх ключевых команд (отдельные слова, которые обычно
     пишутся через "/"), где идет пара 
    ключ : функция к выполнению (название обработчика)
    add_handler(CommandHandler("start", greet_user)) - добавить в словарь 
    команду_ключ : функция_обработчик ("start", greet_user). 
    Примечание!!!: в коде start пишем без "/", так задумано разработчиками

    Если же такой ключ в словаре найдется, то dispatcher запустит функцию обработчика

    (Предварительно импортировали MessageHandler и Filters)
    MessageHandler - Класс обработчика для обработки сообщений телеграммы. 
    Они могут содержать текст, мультимедиа или обновления статуса
    Filters.text - ставим фильтр на то, что будем принимать только текст.

    Примечание: MessageHandler стоит после CommandHandler, 
    чтобы не перехватывать команды (вперед батьки).
    '''    
    dp = mybot.dispatcher
    dp.add_handler(CommandHandler("start", greet_user))
    dp.add_handler(MessageHandler(Filters.text, talk_to_me))
    
    '''
    Шаг 3.2 -"Скажи что поехали!"
    Залогируем в файл информацию о старте бота (сделаем запись в файл bot.log)
    Необходимо, чтобы в последующем вычислять, в какой момент возникла ошибка:
    до, после, во время запуска и т.д.
    '''
    logging.info("Бот стартовал")

    '''
    Шаг 1.2 - "Дай, дай, дай"
    Командуем боту начать ходить в Telegram за сообщениями
    start_polling() - запускает запрос обновлений из Telegram.
    Внутри скобок можно укзать дополнительные настройки, например частота запросов.
    ''' 
    mybot.start_polling()

    '''
    Шаг 1.3 - "Попросил? - Попроси еще раз!"
    Запускаем бота, он будет работать, пока мы его не остановим принудительно
    Зацикливает бота ходить на сервер бесконечно.
    '''
    mybot.idle()

if __name__== '__main__':
    main()