'''
Расстановка имопрта в коде такая, как нужно загружаться по приоритету.
- Библиотека logging - отлавливает и классифицирует ошибки
(изучай отедльно библиотеку), поэтому она первая.
- Библитотека telegram.ext  - содержит основный инструменты для
работы Телеграм, но ошибки важнее,
потому она вторая.
- settings - это нами же созданный файл (модуль),
который содержит коды доступа,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

Шаг 1 - Из библиотеки telegram.ext импортируем Класс Updater,
из которых позже возьмем функции start_polling и idle

Импортировали свой файл.ру settings.py

Шаг 2 - Из библиотеки telegram.ext импортируем Классы словарей
CommandHandler, MessageHandler и Filters для более точной фильтрации
получаемых сообщений

Шаг 3 - Импортируем бибилотеку logging,
с помощье нее сможем получать и обрабатывать сообщения о процессах и ошибках
'''
import logging
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
import ephem
from datetime import date
import settings

'''
Шаг 3.1 -"Не молчи"
(Предварительно импоритровали logging)
По умолчанию telegram.ext не выводит сообщений о процесах и ошибках на экран,
а нам надо знать, что происходит.
Есть 4 типа ошибок. Дебаг - прям все по шагам показывает, Инфо и
еще 2 вида-уровня (вроде, см. документацию к logging).
Нам устраивает уровень INFO.
Поэтому создаем (автоматически) файл bot.log, куда все будет записываться, и
устанавливаем уровень сложности процессов,
которые хотим записывать level=logging.INFO
ormat='%(name)s - %(levelname)s - %(message)s'
 - задали формат выдачи инофрмации
'''

logging.basicConfig(format='%(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO,
                    filename='bot.log')

'''
Шаг 1.4 - "Обходим"
Параметры учебного PROXY-сервера.
Вначале задали прямые параметры (имена, пароли),
но чтобы их не раскрывать - мы сохранили их
в отельный файл settings.py, а сюда только указали переменные
в которых они хранятся.
Чтобы файл не попал на Гит - мы занесли название файла в /.gitignor
'''

PROXY = {
    'proxy_url': settings.PROXY_URL,
    'urllib3_proxy_kwargs': {
        'username': settings.PROXY_USERNAME,
        'password': settings.PROXY_PASSWORD
    }
}

'''
Шаг 4 - "Отвечаем на /start'"

update - содержит полученную информацию от пользователя
и о самом пользователе
context - специальный тумблер (переключатель),
 который нам позволяет сразу из этой фунции
 отправлять комнды папе-боту, через которого мы уже сможем отправлять
  сообщения не только тому
пользователю, что нас вызвал, но и другому, к примеру.

print('Вызван /start') - сообщили себе в консоли, что произошло такое событие

update.message.reply_text('Привет, пользователь! Ты зачем нажал /start?')
 - отвчаем пользователю
update - база данных (содеражия в т.ч. обратный адрес и т.д.)
.message - тип данных - сообщение
.reply_text - отправить текст
() - в скобках содержание текстового ответа, которое получит пользователь
'''


def greet_user(update, context):
    print('Вызван /start')
    # print(update) - посмотрели содержимое update
    # print(1/0) - поверяли то, что без logging ошибки не увидим
    update.message.reply_text('Привет, пользователь! Ты зачем нажал /start?')


'''
Шаг 5 - Отвечаем на входящий текст входяшим текстом
update.message.text - текст полученный от пользователя
update - база данных (содеражищая в т.ч. обратный адрес и т.д.)
.message - тип данных - сообщение
.text - текст полученный от пользователя

update.message.reply_text(user_text) отвечае пользователю его же текстом.
На вход и выход у нас было update.message., отличие только в том, что
.text - полученный текст
.reply_text() - отвечаемый текст
'''


def talk_to_me(update, context):
    user_text = update.message.text
    print(user_text)
    update.message.reply_text(user_text)


'''
Шаг 6 - "А в каком созвездии планета?"
(Загрузили библиотеку для работы с планетами ephem)
(Для загрузки текущей даты загрузили from datetime import date )
'''


def search_constellation(update, context):
    print('Вызван /planet')

    # Сообщение пользователя приводим к нижнему регистру и
    # разбиваем по словам,оформляем в список
    user_message = update.message.text.lower().split()

    # Если сообщение меньше 2-х, т.е. только команда и нет названия планеты, то
    # выдаем сообщение, что искомую планету нужно написать
    if len(user_message) < 2:
        update.message.reply_text('Введите запрос в формате: /planet Name')

    else:
        '''
        1. named_planet =
        user_message[1].capitalize()
         - Определяем имя планеты по индексу 1 в списке,
        и приводим написание с заглавной буквы
        2. coord_planet=
        getattr - преобразует переменную в название планеты и выдает в формате
        ephem.Mars, которая содержит название планеты и ее координаты
        в ephem.Mars() внутри скобок указывается дата
        на которую мы хотим получить координаты, и
        мы вставляем текущую дату: date.today()
        3. constellation =
        ephem.constellation()
         - сама фунция определяющая созвездие по Названию и Кооридинатам,
        которые как раз у нас соржатся в coord_planet
        4. Выдаем сообщение пользователю.

        5. Если планеты нет с првочнике ephem, то он выдает ошибку,
        что такого атрибута у него нет: AttributeError
        И мы "перехватываем" это исключение, и сообщаем пользователю,
         что ничего не нашли.

        '''

        named_planet = user_message[1].capitalize()

        try:
            coord_planet = getattr(ephem, named_planet)(date.today())
            constellation = ephem.constellation(coord_planet)
            update.message.reply_text(
                f'{named_planet} находится в созвездии {constellation}')

        except AttributeError:
            update.message.reply_text(f'Планета {named_planet} не найдена')


def main():
    '''
    Шаг 1.1 - "Предъявите документы"
    (Предварительно импоритровали Updater)

    Создаем бота и передаем ему ключ для авторизации на серверах Telegram:
    mybot - создаем переменную,
     где будут основные параметры на вхождение в систему Телеграма.
    Дальше, мы будем еще применять методы к свойствам Updater,
     но чтобы, не писать каждый раз
    Updater с параметрами на вход - мы все заключили в одной переменной mybot

    Updater("КЛЮЧ, КОТОРЫЙ НАМ ВЫДАЛ BotFather")
     - ключ полученный при регистрации бота

    use_context=True
     - значение по умолчанию, нужно для старых версий, оставляем как есть.

    request_kwargs - опередедяет способ подключения к серверу.
     Можно не включать параметр.
    Но т.к. мы хотим избежать блокировки бота,
     из-за блокриовки Телеграма, то задаем ему параметры,
      как подключиться через удаленный сервер.
    Данный удаленный сервер (см. содержание переменной PROXY) - учебный.
    =PROXY - задаем адрес подключения. см. содрежание переменной в коде выше.
    Библиотека:
     https://python-telegram-bot.readthedocs.io/en/stable/telegram.ext.updater.html
    '''
    mybot = Updater(settings.API_KEY, use_context=True, request_kwargs=PROXY)

    '''
    Шаг 2.1 - "Чё сказал? - То получил"

    dp = mybot.dispatcher
     - Переходим в класс Dispatcher, и создаем для удобства переменную dp
    Диспетчер прогоняет (ищет как ключ) полученный запрос по всем
    Словарям-Handler-ам (CommandHandler, MessageHandler, и прочие)
    и получив обратную связь от первого попавшегося,
    что такой есть - запускает значение по ключу (обработчика)

    (Предварительно импортировали CommandHandler)
    CommandHandler - словарь принимаемх ключевых команд (отдельные слова,
     которые обычно пишутся через "/"), где идет пара
    ключ : функция к выполнению (название обработчика)
    add_handler(CommandHandler("start", greet_user)) - добавить в словарь
    команду_ключ : функция_обработчик ("start", greet_user).
    Примечание!!!: в коде start пишем без "/", так задумано разработчиками

    Если же такой ключ в словаре найдется,
     то dispatcher запустит функцию обработчика

    (Предварительно импортировали MessageHandler и Filters)
    MessageHandler - Класс обработчика для обработки сообщений телеграммы.
    Они могут содержать текст, мультимедиа или обновления статуса
    Filters.text - ставим фильтр на то, что будем принимать только текст.

    Примечание: MessageHandler стоит после CommandHandler,
    чтобы не перехватывать команды (вперед батьки).

    Далее еще будем добавлять Хендлеров к диспетчеру... например про планеты...
    '''
    dp = mybot.dispatcher
    dp.add_handler(CommandHandler("start", greet_user))
    dp.add_handler(CommandHandler("planet", search_constellation))
    dp.add_handler(MessageHandler(Filters.text, talk_to_me))

    '''
    Шаг 3.2 -"Скажи что поехали!"
    Залогируем в файл информацию о старте бота (сделаем запись в файл bot.log)
    Необходимо, чтобы в последующем вычислять, в какой момент возникла ошибка:
    до, после, во время запуска и т.д.
    '''
    logging.info("Бот стартовал")

    '''
    Шаг 1.2 - "Дай, дай, дай"
    Командуем боту начать ходить в Telegram за сообщениями
    start_polling() - запускает запрос обновлений из Telegram.
    Внутри скобок можно укзать дополнительные настройки,
     например частота запросов.
    '''
    mybot.start_polling()

    '''
    Шаг 1.3 - "Попросил? - Попроси еще раз!"
    Запускаем бота, он будет работать, пока мы его не остановим принудительно
    Зацикливает бота ходить на сервер бесконечно.
    '''
    mybot.idle()


if __name__ == '__main__':
    main()
